{
  "version": 3,
  "sources": ["../utils/investmentRepository.ts", "../utils/dynamoClient.ts", "../utils/validators.ts", "../services/investmentService.ts", "../utils/responseHelper.ts", "investment.ts"],
  "sourcesContent": ["/**\n * Investment Repository\n * Data access layer for DynamoDB operations\n */\nimport type { ScanCommandInput } from \"@aws-sdk/lib-dynamodb\";\nimport {\n  DeleteCommand,\n  GetCommand,\n  PutCommand,\n  ScanCommand,\n  UpdateCommand,\n} from \"@aws-sdk/lib-dynamodb\";\nimport { documentClient, tableName } from \"./dynamoClient.js\";\nimport type { InvestmentPayload } from \"./validators.js\";\n\ninterface FilterExpressions {\n  FilterExpression?: string;\n  ExpressionAttributeNames?: Record<string, string>;\n  ExpressionAttributeValues?: Record<string, unknown>;\n}\n\ninterface SortField {\n  field: string;\n  direction: number;\n}\n\nconst NUMERIC_FIELDS = new Set<string>([\"id\", \"price\"]);\n\nconst parseFilterValue = (field: string, value: unknown): unknown => {\n  if (value === undefined || value === null || value === \"\") {\n    return undefined;\n  }\n\n  if (NUMERIC_FIELDS.has(field)) {\n    const numericValue = Number(value);\n    if (!Number.isNaN(numericValue)) {\n      return numericValue;\n    }\n    return undefined;\n  }\n\n  if (field === \"year\") {\n    return String(value);\n  }\n\n  return value;\n};\n\nconst sanitizeFilters = (filters: Record<string, unknown> = {}): Record<string, unknown> => {\n  const sanitized: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(filters)) {\n    const parsedValue = parseFilterValue(key, value);\n    if (parsedValue !== undefined) {\n      sanitized[key] = parsedValue;\n    }\n  }\n  return sanitized;\n};\n\nconst buildFilterExpressions = (filters: Record<string, unknown> = {}): FilterExpressions => {\n  const expressions: string[] = [];\n  const names: Record<string, string> = {};\n  const values: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(filters)) {\n    if (value === undefined || value === null || value === \"\") {\n      continue;\n    }\n\n    const nameKey = `#${key}`;\n    const valueKey = `:${key}`;\n    names[nameKey] = key;\n    values[valueKey] = value;\n    expressions.push(`${nameKey} = ${valueKey}`);\n  }\n\n  if (!expressions.length) {\n    return {};\n  }\n\n  return {\n    FilterExpression: expressions.join(\" AND \"),\n    ExpressionAttributeNames: names,\n    ExpressionAttributeValues: values,\n  };\n};\n\nconst scanAll = async (input: ScanCommandInput): Promise<InvestmentPayload[]> => {\n  const items: InvestmentPayload[] = [];\n  let lastEvaluatedKey: Record<string, unknown> | undefined;\n\n  do {\n    const command = new ScanCommand({\n      ...input,\n      ExclusiveStartKey: lastEvaluatedKey,\n    });\n    const { Items = [], LastEvaluatedKey } = await documentClient.send(command);\n    items.push(...(Items as InvestmentPayload[]));\n    lastEvaluatedKey = LastEvaluatedKey;\n  } while (lastEvaluatedKey);\n\n  return items;\n};\n\nconst parseSortBy = (sortBy: string = \"\"): SortField[] => {\n  return sortBy\n    .split(\",\")\n    .map((field) => field.trim())\n    .filter(Boolean)\n    .map((field) => ({\n      field: field.replace(/^[-+]/, \"\"),\n      direction: field.startsWith(\"-\") ? -1 : 1,\n    }))\n    .filter(({ field }) => !!field);\n};\n\nconst compareValues = (a: unknown, b: unknown): number => {\n  if (a === b) {\n    return 0;\n  }\n  if (a === undefined || a === null) {\n    return 1;\n  }\n  if (b === undefined || b === null) {\n    return -1;\n  }\n  if (typeof a === \"string\" && typeof b === \"string\") {\n    return a.localeCompare(b);\n  }\n  return a > b ? 1 : -1;\n};\n\nconst sortItems = (items: InvestmentPayload[], sortBy: string = \"\"): InvestmentPayload[] => {\n  const sortFields = parseSortBy(sortBy);\n  if (!sortFields.length) {\n    return items;\n  }\n\n  const clonedItems = [...items];\n  clonedItems.sort((itemA, itemB) => {\n    for (const { field, direction } of sortFields) {\n      const comparison = compareValues(itemA?.[field], itemB?.[field]);\n      if (comparison !== 0) {\n        return comparison * direction;\n      }\n    }\n    return 0;\n  });\n  return clonedItems;\n};\n\nexport const investmentRepository = {\n  async getById(id: number): Promise<InvestmentPayload | null> {\n    const { Item } = await documentClient.send(\n      new GetCommand({\n        TableName: tableName,\n        Key: { id },\n      })\n    );\n    return (Item as InvestmentPayload) ?? null;\n  },\n\n  async list({ filters = {}, sortBy }: { filters?: Record<string, unknown>; sortBy?: string } = {}): Promise<InvestmentPayload[]> {\n    const sanitizedFilters = sanitizeFilters(filters);\n    const scanInput: ScanCommandInput = {\n      TableName: tableName,\n      ...buildFilterExpressions(sanitizedFilters),\n    };\n    const items = await scanAll(scanInput);\n    return sortItems(items, sortBy || \"\");\n  },\n\n  async create(investment: InvestmentPayload): Promise<InvestmentPayload> {\n    await documentClient.send(\n      new PutCommand({\n        TableName: tableName,\n        Item: investment,\n        ConditionExpression: \"attribute_not_exists(#id)\",\n        ExpressionAttributeNames: { \"#id\": \"id\" },\n      })\n    );\n    return investment;\n  },\n\n  async update(id: number, updates: Partial<InvestmentPayload>): Promise<InvestmentPayload | null> {\n    const entries = Object.entries(updates).filter(([, value]) => value !== undefined);\n    if (!entries.length) {\n      return null;\n    }\n\n    const setExpressions: string[] = [];\n    const names: Record<string, string> = { \"#id\": \"id\" };\n    const values: Record<string, unknown> = {};\n\n    entries.forEach(([key, value], index) => {\n      const nameKey = `#field_${index}`;\n      const valueKey = `:value_${index}`;\n      names[nameKey] = key;\n      values[valueKey] = value;\n      setExpressions.push(`${nameKey} = ${valueKey}`);\n    });\n\n    try {\n      const { Attributes } = await documentClient.send(\n        new UpdateCommand({\n          TableName: tableName,\n          Key: { id },\n          UpdateExpression: `SET ${setExpressions.join(\", \")}`,\n          ExpressionAttributeNames: names,\n          ExpressionAttributeValues: values,\n          ConditionExpression: \"attribute_exists(#id)\",\n          ReturnValues: \"ALL_NEW\",\n        })\n      );\n      return (Attributes as InvestmentPayload) ?? null;\n    } catch (error) {\n      if ((error as { name?: string }).name === \"ConditionalCheckFailedException\") {\n        return null;\n      }\n      throw error;\n    }\n  },\n\n  async delete(id: number): Promise<InvestmentPayload | null> {\n    const { Attributes } = await documentClient.send(\n      new DeleteCommand({\n        TableName: tableName,\n        Key: { id },\n        ReturnValues: \"ALL_OLD\",\n      })\n    );\n    return (Attributes as InvestmentPayload) ?? null;\n  },\n};\n\n", "/**\n * DynamoDB Client Configuration\n * Initialized outside handler for execution context reuse\n */\nimport { DynamoDBClient } from \"@aws-sdk/client-dynamodb\";\nimport { DynamoDBDocumentClient } from \"@aws-sdk/lib-dynamodb\";\n\nconst TABLE_NAME = process.env.INVESTMENT_TABLE_NAME;\n\nif (!TABLE_NAME) {\n  throw new Error(\"INVESTMENT_TABLE_NAME environment variable is not defined.\");\n}\n\n// Initialize DynamoDB client outside handler for connection reuse\nconst dynamoClient = new DynamoDBClient({\n  region: (process.env.AWS_REGION || process.env.AWS_DEFAULT_REGION || \"us-east-1\") as string,\n  ...(process.env.DYNAMODB_ENDPOINT ? { endpoint: process.env.DYNAMODB_ENDPOINT } : {}),\n});\n\nexport const documentClient = DynamoDBDocumentClient.from(dynamoClient, {\n  marshallOptions: { removeUndefinedValues: true },\n});\n\nexport const tableName: string = TABLE_NAME;\n\n", "/**\n * Input Validation and Sanitization Utilities\n */\n\nexport interface InvestmentPayload {\n  id?: number;\n  year?: string | number;\n  price?: number;\n  target?: string;\n  type1?: string;\n  type2?: string;\n  currency?: string;\n  account?: string;\n  owner?: string;\n  createdAt?: string;\n  [key: string]: unknown;\n}\n\nconst NUMERIC_FIELDS = new Set<string>([\"id\", \"price\"]);\n\n/**\n * Parse request body (handles both string and object)\n */\nexport const parseBody = (body: string | null | undefined): Record<string, unknown> | null => {\n  if (!body) {\n    return null;\n  }\n\n  if (typeof body === \"object\") {\n    return body as Record<string, unknown>;\n  }\n\n  try {\n    return JSON.parse(body) as Record<string, unknown>;\n  } catch (error) {\n    console.error(\"Failed to parse request body:\", error);\n    return null;\n  }\n};\n\n/**\n * Sanitize investment payload for create/update operations\n */\nexport const sanitizeInvestmentPayload = (payload: Record<string, unknown> = {}): InvestmentPayload => {\n  const sanitized: InvestmentPayload = {};\n\n  for (const [key, value] of Object.entries(payload)) {\n    if (value === undefined || value === null) {\n      continue;\n    }\n\n    // Numeric fields\n    if (NUMERIC_FIELDS.has(key)) {\n      const numericValue = Number(value);\n      if (!Number.isNaN(numericValue)) {\n        sanitized[key as keyof InvestmentPayload] = numericValue;\n      }\n      continue;\n    }\n\n    // Year field: ensure stored as string (matches database format)\n    if (key === \"year\") {\n      sanitized.year = value.toString();\n      continue;\n    }\n\n    // Other fields remain as-is\n    sanitized[key] = value;\n  }\n\n  return sanitized;\n};\n\n/**\n * Extract investment ID from API Gateway path\n */\nexport const extractIdFromPath = (path: string): number | null => {\n  const idMatch = path.match(/^\\/investment\\/(\\d+)$/);\n  if (!idMatch) {\n    return null;\n  }\n  return Number(idMatch[1]);\n};\n\n/**\n * Generate unique investment ID\n */\nexport const generateInvestmentId = (): number => {\n  const timestamp = Date.now().toString();\n  const random = Math.floor(Math.random() * 1000).toString().padStart(3, \"0\");\n  return Number(`${timestamp}${random}`);\n};\n\n", "/**\n * Investment Service\n * Business logic layer for investment operations\n */\nimport { investmentRepository } from \"../utils/investmentRepository.js\";\nimport type { InvestmentPayload } from \"../utils/validators.js\";\nimport {\n  extractIdFromPath,\n  generateInvestmentId,\n  parseBody,\n  sanitizeInvestmentPayload,\n} from \"../utils/validators.js\";\n\ninterface ServiceError extends Error {\n  statusCode?: number;\n}\n\nexport const investmentService = {\n  /**\n   * Get investment by ID\n   */\n  async getById(investmentId: number): Promise<InvestmentPayload | null> {\n    return await investmentRepository.getById(investmentId);\n  },\n\n  /**\n   * List investments with optional filters and sorting\n   */\n  async list({ queryParams = {} }: { queryParams?: Record<string, string | undefined> } = {}): Promise<InvestmentPayload[]> {\n    const { sort_by: sortBy, ...filters } = queryParams;\n    return await investmentRepository.list({ filters, sortBy });\n  },\n\n  /**\n   * Create new investment\n   */\n  async create(body: string | null): Promise<InvestmentPayload> {\n    const newInvestment = parseBody(body);\n    if (!newInvestment) {\n      throw new Error(\"Invalid request body\");\n    }\n\n    const investmentPayload = sanitizeInvestmentPayload(newInvestment);\n    \n    // Auto-generate ID if not provided\n    if (investmentPayload.id === undefined) {\n      investmentPayload.id = generateInvestmentId();\n    }\n\n    // Add timestamp\n    if (!investmentPayload.createdAt) {\n      investmentPayload.createdAt = new Date().toISOString();\n    }\n\n    try {\n      return await investmentRepository.create(investmentPayload);\n    } catch (error) {\n      if ((error as { name?: string }).name === \"ConditionalCheckFailedException\") {\n        const conflictError = new Error(\"Investment ID already exists\") as ServiceError;\n        conflictError.statusCode = 409;\n        throw conflictError;\n      }\n      throw error;\n    }\n  },\n\n  /**\n   * Update existing investment\n   */\n  async update(path: string, body: string | null): Promise<InvestmentPayload> {\n    const investmentId = extractIdFromPath(path);\n    if (investmentId === null) {\n      throw new Error(\"Invalid PUT Path\");\n    }\n\n    const updatedInvestment = parseBody(body);\n    if (!updatedInvestment) {\n      throw new Error(\"Invalid request body\");\n    }\n\n    const sanitizedUpdates = sanitizeInvestmentPayload(updatedInvestment);\n    if (!Object.keys(sanitizedUpdates).length) {\n      throw new Error(\"No valid fields provided for update\");\n    }\n\n    const updatedRecord = await investmentRepository.update(investmentId, sanitizedUpdates);\n    if (!updatedRecord) {\n      const notFoundError = new Error(\"Investment Not Found\") as ServiceError;\n      notFoundError.statusCode = 404;\n      throw notFoundError;\n    }\n\n    return updatedRecord;\n  },\n\n  /**\n   * Delete investment\n   */\n  async delete(path: string): Promise<InvestmentPayload> {\n    const investmentId = extractIdFromPath(path);\n    if (investmentId === null) {\n      throw new Error(\"Invalid DELETE Path\");\n    }\n\n    const deleted = await investmentRepository.delete(investmentId);\n    if (!deleted) {\n      const notFoundError = new Error(\"Investment Not Found\") as ServiceError;\n      notFoundError.statusCode = 404;\n      throw notFoundError;\n    }\n\n    return deleted;\n  },\n};\n\n", "/**\n * Response Helper Utility\n * Standardizes API Gateway Lambda Proxy responses\n */\nimport type { APIGatewayProxyResult } from \"aws-lambda\";\n\nexport const createResponse = (\n  status: string,\n  code: number,\n  message: string,\n  data: unknown = null,\n  error: unknown = null\n): APIGatewayProxyResult => {\n  return {\n    statusCode: code,\n    body: JSON.stringify({ status, message, data, error }),\n    headers: {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Methods\": \"POST,GET,OPTIONS,DELETE,PUT,PATCH\",\n      \"Access-Control-Allow-Headers\": \"Content-Type,X-CSRF-TOKEN\",\n    },\n  };\n};\n\n", "/**\n * Investment Lambda Handler\n * Thin handler pattern - delegates to service layer\n */\nimport type { APIGatewayProxyEvent, APIGatewayProxyResult, Context } from \"aws-lambda\";\nimport { investmentService } from \"../services/investmentService.js\";\nimport { createResponse } from \"../utils/responseHelper.js\";\n\ninterface ServiceError extends Error {\n  statusCode?: number;\n}\n\n/**\n * Lambda handler entry point\n */\nexport const lambdaHandler = async (\n  event: APIGatewayProxyEvent,\n  context: Context\n): Promise<APIGatewayProxyResult> => {\n  const { httpMethod, path, body, queryStringParameters } = event;\n\n  try {\n    switch (httpMethod) {\n      case \"GET\":\n        return await handleGet(event);\n      case \"POST\":\n        return await handlePost(body);\n      case \"PUT\":\n        return await handlePut(path, body);\n      case \"DELETE\":\n        return await handleDelete(path);\n      default:\n        return createResponse(\"1\", 405, \"Method Not Allowed\", null, null);\n    }\n  } catch (error) {\n    console.error(\"Handler Error:\", error);\n    \n    // Handle service layer errors with status codes\n    const serviceError = error as ServiceError;\n    const statusCode = serviceError.statusCode || 500;\n    const message = serviceError.message || \"Internal Server Error\";\n    \n    return createResponse(\"1\", statusCode, message, null, {\n      message: serviceError.message,\n    });\n  }\n};\n\n/**\n * Handle GET requests\n */\nconst handleGet = async (event: APIGatewayProxyEvent): Promise<APIGatewayProxyResult> => {\n  const { path, queryStringParameters } = event;\n  const investmentId = extractIdFromPath(path || \"\");\n\n  if (investmentId !== null) {\n    const investment = await investmentService.getById(investmentId);\n    if (!investment) {\n      return createResponse(\"1\", 404, \"Investment Not Found\", null, null);\n    }\n    return createResponse(\"0\", 200, \"OK\", investment, null);\n  }\n\n  const investments = await investmentService.list({\n    queryParams: queryStringParameters || {},\n  });\n  return createResponse(\"0\", 200, \"OK\", investments, null);\n};\n\n/**\n * Handle POST requests\n */\nconst handlePost = async (body: string | null): Promise<APIGatewayProxyResult> => {\n  const created = await investmentService.create(body);\n  return createResponse(\"0\", 201, \"OK\", created, null);\n};\n\n/**\n * Handle PUT requests\n */\nconst handlePut = async (path: string, body: string | null): Promise<APIGatewayProxyResult> => {\n  const updated = await investmentService.update(path, body);\n  return createResponse(\"0\", 200, \"OK\", updated, null);\n};\n\n/**\n * Handle DELETE requests\n */\nconst handleDelete = async (path: string): Promise<APIGatewayProxyResult> => {\n  await investmentService.delete(path);\n  return createResponse(\"0\", 204, \"OK\", null, null);\n};\n\n/**\n * Extract ID from path (helper function)\n */\nconst extractIdFromPath = (path: string): number | null => {\n  const idMatch = path.match(/^\\/investment\\/(\\d+)$/);\n  return idMatch ? Number(idMatch[1]) : null;\n};\n\n"],
  "mappings": "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",
  "names": ["DeleteCommand", "GetCommand", "PutCommand", "ScanCommand", "UpdateCommand", "DynamoDBClient", "DynamoDBDocumentClient", "TABLE_NAME", "dynamoClient", "documentClient", "tableName", "NUMERIC_FIELDS", "parseFilterValue", "field", "value", "numericValue", "sanitizeFilters", "filters", "sanitized", "key", "parsedValue", "buildFilterExpressions", "expressions", "names", "values", "nameKey", "valueKey", "scanAll", "input", "items", "lastEvaluatedKey", "command", "ScanCommand", "Items", "LastEvaluatedKey", "documentClient", "parseSortBy", "sortBy", "compareValues", "a", "b", "sortItems", "sortFields", "clonedItems", "itemA", "itemB", "direction", "comparison", "investmentRepository", "id", "Item", "GetCommand", "tableName", "sanitizedFilters", "scanInput", "investment", "PutCommand", "updates", "entries", "setExpressions", "index", "Attributes", "UpdateCommand", "error", "DeleteCommand", "NUMERIC_FIELDS", "parseBody", "body", "error", "sanitizeInvestmentPayload", "payload", "sanitized", "key", "value", "numericValue", "extractIdFromPath", "path", "idMatch", "generateInvestmentId", "timestamp", "random", "investmentService", "investmentId", "investmentRepository", "queryParams", "sortBy", "filters", "body", "newInvestment", "parseBody", "investmentPayload", "sanitizeInvestmentPayload", "generateInvestmentId", "error", "conflictError", "path", "extractIdFromPath", "updatedInvestment", "sanitizedUpdates", "updatedRecord", "notFoundError", "deleted", "createResponse", "status", "code", "message", "data", "error", "lambdaHandler", "event", "context", "httpMethod", "path", "body", "queryStringParameters", "handleGet", "handlePost", "handlePut", "handleDelete", "createResponse", "error", "serviceError", "statusCode", "message", "investmentId", "extractIdFromPath", "investment", "investmentService", "investments", "created", "updated", "idMatch"]
}
